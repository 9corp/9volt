// This file was generated by counterfeiter
package dalfakes

import (
	"sync"

	"github.com/9corp/9volt/dal"
	"github.com/coreos/etcd/client"
)

type FakeIDal struct {
	GetStub        func(string, *dal.GetOptions) (map[string]string, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
		arg2 *dal.GetOptions
	}
	getReturns struct {
		result1 map[string]string
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	SetStub        func(string, string, *dal.SetOptions) error
	setMutex       sync.RWMutex
	setArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *dal.SetOptions
	}
	setReturns struct {
		result1 error
	}
	setReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(string, bool) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	RefreshStub        func(string, int) error
	refreshMutex       sync.RWMutex
	refreshArgsForCall []struct {
		arg1 string
		arg2 int
	}
	refreshReturns struct {
		result1 error
	}
	refreshReturnsOnCall map[int]struct {
		result1 error
	}
	KeyExistsStub        func(string) (bool, bool, error)
	keyExistsMutex       sync.RWMutex
	keyExistsArgsForCall []struct {
		arg1 string
	}
	keyExistsReturns struct {
		result1 bool
		result2 bool
		result3 error
	}
	keyExistsReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 error
	}
	IsKeyNotFoundStub        func(error) bool
	isKeyNotFoundMutex       sync.RWMutex
	isKeyNotFoundArgsForCall []struct {
		arg1 error
	}
	isKeyNotFoundReturns struct {
		result1 bool
	}
	isKeyNotFoundReturnsOnCall map[int]struct {
		result1 bool
	}
	CreateDirectorStateStub        func(string) error
	createDirectorStateMutex       sync.RWMutex
	createDirectorStateArgsForCall []struct {
		arg1 string
	}
	createDirectorStateReturns struct {
		result1 error
	}
	createDirectorStateReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateDirectorStateStub        func(string, string, bool) error
	updateDirectorStateMutex       sync.RWMutex
	updateDirectorStateArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
	}
	updateDirectorStateReturns struct {
		result1 error
	}
	updateDirectorStateReturnsOnCall map[int]struct {
		result1 error
	}
	NewWatcherStub        func(string, bool) client.Watcher
	newWatcherMutex       sync.RWMutex
	newWatcherArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	newWatcherReturns struct {
		result1 client.Watcher
	}
	newWatcherReturnsOnCall map[int]struct {
		result1 client.Watcher
	}
	NewWatcherForOverwatchStub        func(string, bool) (client.Watcher, error)
	newWatcherForOverwatchMutex       sync.RWMutex
	newWatcherForOverwatchArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	newWatcherForOverwatchReturns struct {
		result1 client.Watcher
		result2 error
	}
	newWatcherForOverwatchReturnsOnCall map[int]struct {
		result1 client.Watcher
		result2 error
	}
	GetClusterMembersStub        func() ([]string, error)
	getClusterMembersMutex       sync.RWMutex
	getClusterMembersArgsForCall []struct{}
	getClusterMembersReturns     struct {
		result1 []string
		result2 error
	}
	getClusterMembersReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetCheckKeysStub        func() ([]string, error)
	getCheckKeysMutex       sync.RWMutex
	getCheckKeysArgsForCall []struct{}
	getCheckKeysReturns     struct {
		result1 []string
		result2 error
	}
	getCheckKeysReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetCheckKeysWithMemberTagStub        func() (map[string]string, error)
	getCheckKeysWithMemberTagMutex       sync.RWMutex
	getCheckKeysWithMemberTagArgsForCall []struct{}
	getCheckKeysWithMemberTagReturns     struct {
		result1 map[string]string
		result2 error
	}
	getCheckKeysWithMemberTagReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 error
	}
	CreateCheckReferenceStub        func(string, string) error
	createCheckReferenceMutex       sync.RWMutex
	createCheckReferenceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createCheckReferenceReturns struct {
		result1 error
	}
	createCheckReferenceReturnsOnCall map[int]struct {
		result1 error
	}
	ClearCheckReferenceStub        func(string, string) error
	clearCheckReferenceMutex       sync.RWMutex
	clearCheckReferenceArgsForCall []struct {
		arg1 string
		arg2 string
	}
	clearCheckReferenceReturns struct {
		result1 error
	}
	clearCheckReferenceReturnsOnCall map[int]struct {
		result1 error
	}
	ClearCheckReferencesStub        func(string) error
	clearCheckReferencesMutex       sync.RWMutex
	clearCheckReferencesArgsForCall []struct {
		arg1 string
	}
	clearCheckReferencesReturns struct {
		result1 error
	}
	clearCheckReferencesReturnsOnCall map[int]struct {
		result1 error
	}
	FetchAllMemberRefsStub        func() (map[string]string, []string, error)
	fetchAllMemberRefsMutex       sync.RWMutex
	fetchAllMemberRefsArgsForCall []struct{}
	fetchAllMemberRefsReturns     struct {
		result1 map[string]string
		result2 []string
		result3 error
	}
	fetchAllMemberRefsReturnsOnCall map[int]struct {
		result1 map[string]string
		result2 []string
		result3 error
	}
	FetchCheckStatsStub        func() (map[string]*dal.MemberStat, error)
	fetchCheckStatsMutex       sync.RWMutex
	fetchCheckStatsArgsForCall []struct{}
	fetchCheckStatsReturns     struct {
		result1 map[string]*dal.MemberStat
		result2 error
	}
	fetchCheckStatsReturnsOnCall map[int]struct {
		result1 map[string]*dal.MemberStat
		result2 error
	}
	FetchAlerterConfigStub        func(string) (string, error)
	fetchAlerterConfigMutex       sync.RWMutex
	fetchAlerterConfigArgsForCall []struct {
		arg1 string
	}
	fetchAlerterConfigReturns struct {
		result1 string
		result2 error
	}
	fetchAlerterConfigReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FetchStateStub        func() ([]byte, error)
	fetchStateMutex       sync.RWMutex
	fetchStateArgsForCall []struct{}
	fetchStateReturns     struct {
		result1 []byte
		result2 error
	}
	fetchStateReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	FetchStateWithTagsStub        func([]string) ([]byte, error)
	fetchStateWithTagsMutex       sync.RWMutex
	fetchStateWithTagsArgsForCall []struct {
		arg1 []string
	}
	fetchStateWithTagsReturns struct {
		result1 []byte
		result2 error
	}
	fetchStateWithTagsReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	UpdateCheckStateStub        func(bool, string) error
	updateCheckStateMutex       sync.RWMutex
	updateCheckStateArgsForCall []struct {
		arg1 bool
		arg2 string
	}
	updateCheckStateReturns struct {
		result1 error
	}
	updateCheckStateReturnsOnCall map[int]struct {
		result1 error
	}
	GetClusterStatsStub        func() (*dal.ClusterStats, error)
	getClusterStatsMutex       sync.RWMutex
	getClusterStatsArgsForCall []struct{}
	getClusterStatsReturns     struct {
		result1 *dal.ClusterStats
		result2 error
	}
	getClusterStatsReturnsOnCall map[int]struct {
		result1 *dal.ClusterStats
		result2 error
	}
	FetchEventsStub        func([]string) ([]byte, error)
	fetchEventsMutex       sync.RWMutex
	fetchEventsArgsForCall []struct {
		arg1 []string
	}
	fetchEventsReturns struct {
		result1 []byte
		result2 error
	}
	fetchEventsReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetClusterMembersWithTagsStub        func() (map[string][]string, error)
	getClusterMembersWithTagsMutex       sync.RWMutex
	getClusterMembersWithTagsArgsForCall []struct{}
	getClusterMembersWithTagsReturns     struct {
		result1 map[string][]string
		result2 error
	}
	getClusterMembersWithTagsReturnsOnCall map[int]struct {
		result1 map[string][]string
		result2 error
	}
	GetClusterMemberTagsStub        func(string) ([]string, error)
	getClusterMemberTagsMutex       sync.RWMutex
	getClusterMemberTagsArgsForCall []struct {
		arg1 string
	}
	getClusterMemberTagsReturns struct {
		result1 []string
		result2 error
	}
	getClusterMemberTagsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetCheckMemberTagStub        func(string) (string, error)
	getCheckMemberTagMutex       sync.RWMutex
	getCheckMemberTagArgsForCall []struct {
		arg1 string
	}
	getCheckMemberTagReturns struct {
		result1 string
		result2 error
	}
	getCheckMemberTagReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	PushConfigsStub        func(string, map[string][]byte) (int, int, error)
	pushConfigsMutex       sync.RWMutex
	pushConfigsArgsForCall []struct {
		arg1 string
		arg2 map[string][]byte
	}
	pushConfigsReturns struct {
		result1 int
		result2 int
		result3 error
	}
	pushConfigsReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 error
	}
	PushFullConfigsStub        func(*dal.FullConfigs) (*dal.CfgUtilPushStats, []string)
	pushFullConfigsMutex       sync.RWMutex
	pushFullConfigsArgsForCall []struct {
		arg1 *dal.FullConfigs
	}
	pushFullConfigsReturns struct {
		result1 *dal.CfgUtilPushStats
		result2 []string
	}
	pushFullConfigsReturnsOnCall map[int]struct {
		result1 *dal.CfgUtilPushStats
		result2 []string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIDal) Get(arg1 string, arg2 *dal.GetOptions) (map[string]string, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
		arg2 *dal.GetOptions
	}{arg1, arg2})
	fake.recordInvocation("Get", []interface{}{arg1, arg2})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakeIDal) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeIDal) GetArgsForCall(i int) (string, *dal.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].arg1, fake.getArgsForCall[i].arg2
}

func (fake *FakeIDal) GetReturns(result1 map[string]string, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) Set(arg1 string, arg2 string, arg3 *dal.SetOptions) error {
	fake.setMutex.Lock()
	ret, specificReturn := fake.setReturnsOnCall[len(fake.setArgsForCall)]
	fake.setArgsForCall = append(fake.setArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *dal.SetOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("Set", []interface{}{arg1, arg2, arg3})
	fake.setMutex.Unlock()
	if fake.SetStub != nil {
		return fake.SetStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setReturns.result1
}

func (fake *FakeIDal) SetCallCount() int {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return len(fake.setArgsForCall)
}

func (fake *FakeIDal) SetArgsForCall(i int) (string, string, *dal.SetOptions) {
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	return fake.setArgsForCall[i].arg1, fake.setArgsForCall[i].arg2, fake.setArgsForCall[i].arg3
}

func (fake *FakeIDal) SetReturns(result1 error) {
	fake.SetStub = nil
	fake.setReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) SetReturnsOnCall(i int, result1 error) {
	fake.SetStub = nil
	if fake.setReturnsOnCall == nil {
		fake.setReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) Delete(arg1 string, arg2 bool) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeIDal) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeIDal) DeleteArgsForCall(i int) (string, bool) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].arg1, fake.deleteArgsForCall[i].arg2
}

func (fake *FakeIDal) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) Refresh(arg1 string, arg2 int) error {
	fake.refreshMutex.Lock()
	ret, specificReturn := fake.refreshReturnsOnCall[len(fake.refreshArgsForCall)]
	fake.refreshArgsForCall = append(fake.refreshArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("Refresh", []interface{}{arg1, arg2})
	fake.refreshMutex.Unlock()
	if fake.RefreshStub != nil {
		return fake.RefreshStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.refreshReturns.result1
}

func (fake *FakeIDal) RefreshCallCount() int {
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	return len(fake.refreshArgsForCall)
}

func (fake *FakeIDal) RefreshArgsForCall(i int) (string, int) {
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	return fake.refreshArgsForCall[i].arg1, fake.refreshArgsForCall[i].arg2
}

func (fake *FakeIDal) RefreshReturns(result1 error) {
	fake.RefreshStub = nil
	fake.refreshReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) RefreshReturnsOnCall(i int, result1 error) {
	fake.RefreshStub = nil
	if fake.refreshReturnsOnCall == nil {
		fake.refreshReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.refreshReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) KeyExists(arg1 string) (bool, bool, error) {
	fake.keyExistsMutex.Lock()
	ret, specificReturn := fake.keyExistsReturnsOnCall[len(fake.keyExistsArgsForCall)]
	fake.keyExistsArgsForCall = append(fake.keyExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("KeyExists", []interface{}{arg1})
	fake.keyExistsMutex.Unlock()
	if fake.KeyExistsStub != nil {
		return fake.KeyExistsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.keyExistsReturns.result1, fake.keyExistsReturns.result2, fake.keyExistsReturns.result3
}

func (fake *FakeIDal) KeyExistsCallCount() int {
	fake.keyExistsMutex.RLock()
	defer fake.keyExistsMutex.RUnlock()
	return len(fake.keyExistsArgsForCall)
}

func (fake *FakeIDal) KeyExistsArgsForCall(i int) string {
	fake.keyExistsMutex.RLock()
	defer fake.keyExistsMutex.RUnlock()
	return fake.keyExistsArgsForCall[i].arg1
}

func (fake *FakeIDal) KeyExistsReturns(result1 bool, result2 bool, result3 error) {
	fake.KeyExistsStub = nil
	fake.keyExistsReturns = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIDal) KeyExistsReturnsOnCall(i int, result1 bool, result2 bool, result3 error) {
	fake.KeyExistsStub = nil
	if fake.keyExistsReturnsOnCall == nil {
		fake.keyExistsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 error
		})
	}
	fake.keyExistsReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIDal) IsKeyNotFound(arg1 error) bool {
	fake.isKeyNotFoundMutex.Lock()
	ret, specificReturn := fake.isKeyNotFoundReturnsOnCall[len(fake.isKeyNotFoundArgsForCall)]
	fake.isKeyNotFoundArgsForCall = append(fake.isKeyNotFoundArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("IsKeyNotFound", []interface{}{arg1})
	fake.isKeyNotFoundMutex.Unlock()
	if fake.IsKeyNotFoundStub != nil {
		return fake.IsKeyNotFoundStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isKeyNotFoundReturns.result1
}

func (fake *FakeIDal) IsKeyNotFoundCallCount() int {
	fake.isKeyNotFoundMutex.RLock()
	defer fake.isKeyNotFoundMutex.RUnlock()
	return len(fake.isKeyNotFoundArgsForCall)
}

func (fake *FakeIDal) IsKeyNotFoundArgsForCall(i int) error {
	fake.isKeyNotFoundMutex.RLock()
	defer fake.isKeyNotFoundMutex.RUnlock()
	return fake.isKeyNotFoundArgsForCall[i].arg1
}

func (fake *FakeIDal) IsKeyNotFoundReturns(result1 bool) {
	fake.IsKeyNotFoundStub = nil
	fake.isKeyNotFoundReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIDal) IsKeyNotFoundReturnsOnCall(i int, result1 bool) {
	fake.IsKeyNotFoundStub = nil
	if fake.isKeyNotFoundReturnsOnCall == nil {
		fake.isKeyNotFoundReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isKeyNotFoundReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeIDal) CreateDirectorState(arg1 string) error {
	fake.createDirectorStateMutex.Lock()
	ret, specificReturn := fake.createDirectorStateReturnsOnCall[len(fake.createDirectorStateArgsForCall)]
	fake.createDirectorStateArgsForCall = append(fake.createDirectorStateArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateDirectorState", []interface{}{arg1})
	fake.createDirectorStateMutex.Unlock()
	if fake.CreateDirectorStateStub != nil {
		return fake.CreateDirectorStateStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createDirectorStateReturns.result1
}

func (fake *FakeIDal) CreateDirectorStateCallCount() int {
	fake.createDirectorStateMutex.RLock()
	defer fake.createDirectorStateMutex.RUnlock()
	return len(fake.createDirectorStateArgsForCall)
}

func (fake *FakeIDal) CreateDirectorStateArgsForCall(i int) string {
	fake.createDirectorStateMutex.RLock()
	defer fake.createDirectorStateMutex.RUnlock()
	return fake.createDirectorStateArgsForCall[i].arg1
}

func (fake *FakeIDal) CreateDirectorStateReturns(result1 error) {
	fake.CreateDirectorStateStub = nil
	fake.createDirectorStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) CreateDirectorStateReturnsOnCall(i int, result1 error) {
	fake.CreateDirectorStateStub = nil
	if fake.createDirectorStateReturnsOnCall == nil {
		fake.createDirectorStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createDirectorStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) UpdateDirectorState(arg1 string, arg2 string, arg3 bool) error {
	fake.updateDirectorStateMutex.Lock()
	ret, specificReturn := fake.updateDirectorStateReturnsOnCall[len(fake.updateDirectorStateArgsForCall)]
	fake.updateDirectorStateArgsForCall = append(fake.updateDirectorStateArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateDirectorState", []interface{}{arg1, arg2, arg3})
	fake.updateDirectorStateMutex.Unlock()
	if fake.UpdateDirectorStateStub != nil {
		return fake.UpdateDirectorStateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateDirectorStateReturns.result1
}

func (fake *FakeIDal) UpdateDirectorStateCallCount() int {
	fake.updateDirectorStateMutex.RLock()
	defer fake.updateDirectorStateMutex.RUnlock()
	return len(fake.updateDirectorStateArgsForCall)
}

func (fake *FakeIDal) UpdateDirectorStateArgsForCall(i int) (string, string, bool) {
	fake.updateDirectorStateMutex.RLock()
	defer fake.updateDirectorStateMutex.RUnlock()
	return fake.updateDirectorStateArgsForCall[i].arg1, fake.updateDirectorStateArgsForCall[i].arg2, fake.updateDirectorStateArgsForCall[i].arg3
}

func (fake *FakeIDal) UpdateDirectorStateReturns(result1 error) {
	fake.UpdateDirectorStateStub = nil
	fake.updateDirectorStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) UpdateDirectorStateReturnsOnCall(i int, result1 error) {
	fake.UpdateDirectorStateStub = nil
	if fake.updateDirectorStateReturnsOnCall == nil {
		fake.updateDirectorStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateDirectorStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) NewWatcher(arg1 string, arg2 bool) client.Watcher {
	fake.newWatcherMutex.Lock()
	ret, specificReturn := fake.newWatcherReturnsOnCall[len(fake.newWatcherArgsForCall)]
	fake.newWatcherArgsForCall = append(fake.newWatcherArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("NewWatcher", []interface{}{arg1, arg2})
	fake.newWatcherMutex.Unlock()
	if fake.NewWatcherStub != nil {
		return fake.NewWatcherStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newWatcherReturns.result1
}

func (fake *FakeIDal) NewWatcherCallCount() int {
	fake.newWatcherMutex.RLock()
	defer fake.newWatcherMutex.RUnlock()
	return len(fake.newWatcherArgsForCall)
}

func (fake *FakeIDal) NewWatcherArgsForCall(i int) (string, bool) {
	fake.newWatcherMutex.RLock()
	defer fake.newWatcherMutex.RUnlock()
	return fake.newWatcherArgsForCall[i].arg1, fake.newWatcherArgsForCall[i].arg2
}

func (fake *FakeIDal) NewWatcherReturns(result1 client.Watcher) {
	fake.NewWatcherStub = nil
	fake.newWatcherReturns = struct {
		result1 client.Watcher
	}{result1}
}

func (fake *FakeIDal) NewWatcherReturnsOnCall(i int, result1 client.Watcher) {
	fake.NewWatcherStub = nil
	if fake.newWatcherReturnsOnCall == nil {
		fake.newWatcherReturnsOnCall = make(map[int]struct {
			result1 client.Watcher
		})
	}
	fake.newWatcherReturnsOnCall[i] = struct {
		result1 client.Watcher
	}{result1}
}

func (fake *FakeIDal) NewWatcherForOverwatch(arg1 string, arg2 bool) (client.Watcher, error) {
	fake.newWatcherForOverwatchMutex.Lock()
	ret, specificReturn := fake.newWatcherForOverwatchReturnsOnCall[len(fake.newWatcherForOverwatchArgsForCall)]
	fake.newWatcherForOverwatchArgsForCall = append(fake.newWatcherForOverwatchArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	fake.recordInvocation("NewWatcherForOverwatch", []interface{}{arg1, arg2})
	fake.newWatcherForOverwatchMutex.Unlock()
	if fake.NewWatcherForOverwatchStub != nil {
		return fake.NewWatcherForOverwatchStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.newWatcherForOverwatchReturns.result1, fake.newWatcherForOverwatchReturns.result2
}

func (fake *FakeIDal) NewWatcherForOverwatchCallCount() int {
	fake.newWatcherForOverwatchMutex.RLock()
	defer fake.newWatcherForOverwatchMutex.RUnlock()
	return len(fake.newWatcherForOverwatchArgsForCall)
}

func (fake *FakeIDal) NewWatcherForOverwatchArgsForCall(i int) (string, bool) {
	fake.newWatcherForOverwatchMutex.RLock()
	defer fake.newWatcherForOverwatchMutex.RUnlock()
	return fake.newWatcherForOverwatchArgsForCall[i].arg1, fake.newWatcherForOverwatchArgsForCall[i].arg2
}

func (fake *FakeIDal) NewWatcherForOverwatchReturns(result1 client.Watcher, result2 error) {
	fake.NewWatcherForOverwatchStub = nil
	fake.newWatcherForOverwatchReturns = struct {
		result1 client.Watcher
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) NewWatcherForOverwatchReturnsOnCall(i int, result1 client.Watcher, result2 error) {
	fake.NewWatcherForOverwatchStub = nil
	if fake.newWatcherForOverwatchReturnsOnCall == nil {
		fake.newWatcherForOverwatchReturnsOnCall = make(map[int]struct {
			result1 client.Watcher
			result2 error
		})
	}
	fake.newWatcherForOverwatchReturnsOnCall[i] = struct {
		result1 client.Watcher
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterMembers() ([]string, error) {
	fake.getClusterMembersMutex.Lock()
	ret, specificReturn := fake.getClusterMembersReturnsOnCall[len(fake.getClusterMembersArgsForCall)]
	fake.getClusterMembersArgsForCall = append(fake.getClusterMembersArgsForCall, struct{}{})
	fake.recordInvocation("GetClusterMembers", []interface{}{})
	fake.getClusterMembersMutex.Unlock()
	if fake.GetClusterMembersStub != nil {
		return fake.GetClusterMembersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getClusterMembersReturns.result1, fake.getClusterMembersReturns.result2
}

func (fake *FakeIDal) GetClusterMembersCallCount() int {
	fake.getClusterMembersMutex.RLock()
	defer fake.getClusterMembersMutex.RUnlock()
	return len(fake.getClusterMembersArgsForCall)
}

func (fake *FakeIDal) GetClusterMembersReturns(result1 []string, result2 error) {
	fake.GetClusterMembersStub = nil
	fake.getClusterMembersReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterMembersReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetClusterMembersStub = nil
	if fake.getClusterMembersReturnsOnCall == nil {
		fake.getClusterMembersReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getClusterMembersReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetCheckKeys() ([]string, error) {
	fake.getCheckKeysMutex.Lock()
	ret, specificReturn := fake.getCheckKeysReturnsOnCall[len(fake.getCheckKeysArgsForCall)]
	fake.getCheckKeysArgsForCall = append(fake.getCheckKeysArgsForCall, struct{}{})
	fake.recordInvocation("GetCheckKeys", []interface{}{})
	fake.getCheckKeysMutex.Unlock()
	if fake.GetCheckKeysStub != nil {
		return fake.GetCheckKeysStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCheckKeysReturns.result1, fake.getCheckKeysReturns.result2
}

func (fake *FakeIDal) GetCheckKeysCallCount() int {
	fake.getCheckKeysMutex.RLock()
	defer fake.getCheckKeysMutex.RUnlock()
	return len(fake.getCheckKeysArgsForCall)
}

func (fake *FakeIDal) GetCheckKeysReturns(result1 []string, result2 error) {
	fake.GetCheckKeysStub = nil
	fake.getCheckKeysReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetCheckKeysReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetCheckKeysStub = nil
	if fake.getCheckKeysReturnsOnCall == nil {
		fake.getCheckKeysReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getCheckKeysReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetCheckKeysWithMemberTag() (map[string]string, error) {
	fake.getCheckKeysWithMemberTagMutex.Lock()
	ret, specificReturn := fake.getCheckKeysWithMemberTagReturnsOnCall[len(fake.getCheckKeysWithMemberTagArgsForCall)]
	fake.getCheckKeysWithMemberTagArgsForCall = append(fake.getCheckKeysWithMemberTagArgsForCall, struct{}{})
	fake.recordInvocation("GetCheckKeysWithMemberTag", []interface{}{})
	fake.getCheckKeysWithMemberTagMutex.Unlock()
	if fake.GetCheckKeysWithMemberTagStub != nil {
		return fake.GetCheckKeysWithMemberTagStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCheckKeysWithMemberTagReturns.result1, fake.getCheckKeysWithMemberTagReturns.result2
}

func (fake *FakeIDal) GetCheckKeysWithMemberTagCallCount() int {
	fake.getCheckKeysWithMemberTagMutex.RLock()
	defer fake.getCheckKeysWithMemberTagMutex.RUnlock()
	return len(fake.getCheckKeysWithMemberTagArgsForCall)
}

func (fake *FakeIDal) GetCheckKeysWithMemberTagReturns(result1 map[string]string, result2 error) {
	fake.GetCheckKeysWithMemberTagStub = nil
	fake.getCheckKeysWithMemberTagReturns = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetCheckKeysWithMemberTagReturnsOnCall(i int, result1 map[string]string, result2 error) {
	fake.GetCheckKeysWithMemberTagStub = nil
	if fake.getCheckKeysWithMemberTagReturnsOnCall == nil {
		fake.getCheckKeysWithMemberTagReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 error
		})
	}
	fake.getCheckKeysWithMemberTagReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) CreateCheckReference(arg1 string, arg2 string) error {
	fake.createCheckReferenceMutex.Lock()
	ret, specificReturn := fake.createCheckReferenceReturnsOnCall[len(fake.createCheckReferenceArgsForCall)]
	fake.createCheckReferenceArgsForCall = append(fake.createCheckReferenceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateCheckReference", []interface{}{arg1, arg2})
	fake.createCheckReferenceMutex.Unlock()
	if fake.CreateCheckReferenceStub != nil {
		return fake.CreateCheckReferenceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createCheckReferenceReturns.result1
}

func (fake *FakeIDal) CreateCheckReferenceCallCount() int {
	fake.createCheckReferenceMutex.RLock()
	defer fake.createCheckReferenceMutex.RUnlock()
	return len(fake.createCheckReferenceArgsForCall)
}

func (fake *FakeIDal) CreateCheckReferenceArgsForCall(i int) (string, string) {
	fake.createCheckReferenceMutex.RLock()
	defer fake.createCheckReferenceMutex.RUnlock()
	return fake.createCheckReferenceArgsForCall[i].arg1, fake.createCheckReferenceArgsForCall[i].arg2
}

func (fake *FakeIDal) CreateCheckReferenceReturns(result1 error) {
	fake.CreateCheckReferenceStub = nil
	fake.createCheckReferenceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) CreateCheckReferenceReturnsOnCall(i int, result1 error) {
	fake.CreateCheckReferenceStub = nil
	if fake.createCheckReferenceReturnsOnCall == nil {
		fake.createCheckReferenceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createCheckReferenceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) ClearCheckReference(arg1 string, arg2 string) error {
	fake.clearCheckReferenceMutex.Lock()
	ret, specificReturn := fake.clearCheckReferenceReturnsOnCall[len(fake.clearCheckReferenceArgsForCall)]
	fake.clearCheckReferenceArgsForCall = append(fake.clearCheckReferenceArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ClearCheckReference", []interface{}{arg1, arg2})
	fake.clearCheckReferenceMutex.Unlock()
	if fake.ClearCheckReferenceStub != nil {
		return fake.ClearCheckReferenceStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.clearCheckReferenceReturns.result1
}

func (fake *FakeIDal) ClearCheckReferenceCallCount() int {
	fake.clearCheckReferenceMutex.RLock()
	defer fake.clearCheckReferenceMutex.RUnlock()
	return len(fake.clearCheckReferenceArgsForCall)
}

func (fake *FakeIDal) ClearCheckReferenceArgsForCall(i int) (string, string) {
	fake.clearCheckReferenceMutex.RLock()
	defer fake.clearCheckReferenceMutex.RUnlock()
	return fake.clearCheckReferenceArgsForCall[i].arg1, fake.clearCheckReferenceArgsForCall[i].arg2
}

func (fake *FakeIDal) ClearCheckReferenceReturns(result1 error) {
	fake.ClearCheckReferenceStub = nil
	fake.clearCheckReferenceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) ClearCheckReferenceReturnsOnCall(i int, result1 error) {
	fake.ClearCheckReferenceStub = nil
	if fake.clearCheckReferenceReturnsOnCall == nil {
		fake.clearCheckReferenceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearCheckReferenceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) ClearCheckReferences(arg1 string) error {
	fake.clearCheckReferencesMutex.Lock()
	ret, specificReturn := fake.clearCheckReferencesReturnsOnCall[len(fake.clearCheckReferencesArgsForCall)]
	fake.clearCheckReferencesArgsForCall = append(fake.clearCheckReferencesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ClearCheckReferences", []interface{}{arg1})
	fake.clearCheckReferencesMutex.Unlock()
	if fake.ClearCheckReferencesStub != nil {
		return fake.ClearCheckReferencesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.clearCheckReferencesReturns.result1
}

func (fake *FakeIDal) ClearCheckReferencesCallCount() int {
	fake.clearCheckReferencesMutex.RLock()
	defer fake.clearCheckReferencesMutex.RUnlock()
	return len(fake.clearCheckReferencesArgsForCall)
}

func (fake *FakeIDal) ClearCheckReferencesArgsForCall(i int) string {
	fake.clearCheckReferencesMutex.RLock()
	defer fake.clearCheckReferencesMutex.RUnlock()
	return fake.clearCheckReferencesArgsForCall[i].arg1
}

func (fake *FakeIDal) ClearCheckReferencesReturns(result1 error) {
	fake.ClearCheckReferencesStub = nil
	fake.clearCheckReferencesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) ClearCheckReferencesReturnsOnCall(i int, result1 error) {
	fake.ClearCheckReferencesStub = nil
	if fake.clearCheckReferencesReturnsOnCall == nil {
		fake.clearCheckReferencesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearCheckReferencesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) FetchAllMemberRefs() (map[string]string, []string, error) {
	fake.fetchAllMemberRefsMutex.Lock()
	ret, specificReturn := fake.fetchAllMemberRefsReturnsOnCall[len(fake.fetchAllMemberRefsArgsForCall)]
	fake.fetchAllMemberRefsArgsForCall = append(fake.fetchAllMemberRefsArgsForCall, struct{}{})
	fake.recordInvocation("FetchAllMemberRefs", []interface{}{})
	fake.fetchAllMemberRefsMutex.Unlock()
	if fake.FetchAllMemberRefsStub != nil {
		return fake.FetchAllMemberRefsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.fetchAllMemberRefsReturns.result1, fake.fetchAllMemberRefsReturns.result2, fake.fetchAllMemberRefsReturns.result3
}

func (fake *FakeIDal) FetchAllMemberRefsCallCount() int {
	fake.fetchAllMemberRefsMutex.RLock()
	defer fake.fetchAllMemberRefsMutex.RUnlock()
	return len(fake.fetchAllMemberRefsArgsForCall)
}

func (fake *FakeIDal) FetchAllMemberRefsReturns(result1 map[string]string, result2 []string, result3 error) {
	fake.FetchAllMemberRefsStub = nil
	fake.fetchAllMemberRefsReturns = struct {
		result1 map[string]string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIDal) FetchAllMemberRefsReturnsOnCall(i int, result1 map[string]string, result2 []string, result3 error) {
	fake.FetchAllMemberRefsStub = nil
	if fake.fetchAllMemberRefsReturnsOnCall == nil {
		fake.fetchAllMemberRefsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
			result2 []string
			result3 error
		})
	}
	fake.fetchAllMemberRefsReturnsOnCall[i] = struct {
		result1 map[string]string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIDal) FetchCheckStats() (map[string]*dal.MemberStat, error) {
	fake.fetchCheckStatsMutex.Lock()
	ret, specificReturn := fake.fetchCheckStatsReturnsOnCall[len(fake.fetchCheckStatsArgsForCall)]
	fake.fetchCheckStatsArgsForCall = append(fake.fetchCheckStatsArgsForCall, struct{}{})
	fake.recordInvocation("FetchCheckStats", []interface{}{})
	fake.fetchCheckStatsMutex.Unlock()
	if fake.FetchCheckStatsStub != nil {
		return fake.FetchCheckStatsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchCheckStatsReturns.result1, fake.fetchCheckStatsReturns.result2
}

func (fake *FakeIDal) FetchCheckStatsCallCount() int {
	fake.fetchCheckStatsMutex.RLock()
	defer fake.fetchCheckStatsMutex.RUnlock()
	return len(fake.fetchCheckStatsArgsForCall)
}

func (fake *FakeIDal) FetchCheckStatsReturns(result1 map[string]*dal.MemberStat, result2 error) {
	fake.FetchCheckStatsStub = nil
	fake.fetchCheckStatsReturns = struct {
		result1 map[string]*dal.MemberStat
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchCheckStatsReturnsOnCall(i int, result1 map[string]*dal.MemberStat, result2 error) {
	fake.FetchCheckStatsStub = nil
	if fake.fetchCheckStatsReturnsOnCall == nil {
		fake.fetchCheckStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]*dal.MemberStat
			result2 error
		})
	}
	fake.fetchCheckStatsReturnsOnCall[i] = struct {
		result1 map[string]*dal.MemberStat
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchAlerterConfig(arg1 string) (string, error) {
	fake.fetchAlerterConfigMutex.Lock()
	ret, specificReturn := fake.fetchAlerterConfigReturnsOnCall[len(fake.fetchAlerterConfigArgsForCall)]
	fake.fetchAlerterConfigArgsForCall = append(fake.fetchAlerterConfigArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FetchAlerterConfig", []interface{}{arg1})
	fake.fetchAlerterConfigMutex.Unlock()
	if fake.FetchAlerterConfigStub != nil {
		return fake.FetchAlerterConfigStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchAlerterConfigReturns.result1, fake.fetchAlerterConfigReturns.result2
}

func (fake *FakeIDal) FetchAlerterConfigCallCount() int {
	fake.fetchAlerterConfigMutex.RLock()
	defer fake.fetchAlerterConfigMutex.RUnlock()
	return len(fake.fetchAlerterConfigArgsForCall)
}

func (fake *FakeIDal) FetchAlerterConfigArgsForCall(i int) string {
	fake.fetchAlerterConfigMutex.RLock()
	defer fake.fetchAlerterConfigMutex.RUnlock()
	return fake.fetchAlerterConfigArgsForCall[i].arg1
}

func (fake *FakeIDal) FetchAlerterConfigReturns(result1 string, result2 error) {
	fake.FetchAlerterConfigStub = nil
	fake.fetchAlerterConfigReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchAlerterConfigReturnsOnCall(i int, result1 string, result2 error) {
	fake.FetchAlerterConfigStub = nil
	if fake.fetchAlerterConfigReturnsOnCall == nil {
		fake.fetchAlerterConfigReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.fetchAlerterConfigReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchState() ([]byte, error) {
	fake.fetchStateMutex.Lock()
	ret, specificReturn := fake.fetchStateReturnsOnCall[len(fake.fetchStateArgsForCall)]
	fake.fetchStateArgsForCall = append(fake.fetchStateArgsForCall, struct{}{})
	fake.recordInvocation("FetchState", []interface{}{})
	fake.fetchStateMutex.Unlock()
	if fake.FetchStateStub != nil {
		return fake.FetchStateStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchStateReturns.result1, fake.fetchStateReturns.result2
}

func (fake *FakeIDal) FetchStateCallCount() int {
	fake.fetchStateMutex.RLock()
	defer fake.fetchStateMutex.RUnlock()
	return len(fake.fetchStateArgsForCall)
}

func (fake *FakeIDal) FetchStateReturns(result1 []byte, result2 error) {
	fake.FetchStateStub = nil
	fake.fetchStateReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchStateReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.FetchStateStub = nil
	if fake.fetchStateReturnsOnCall == nil {
		fake.fetchStateReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.fetchStateReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchStateWithTags(arg1 []string) ([]byte, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.fetchStateWithTagsMutex.Lock()
	ret, specificReturn := fake.fetchStateWithTagsReturnsOnCall[len(fake.fetchStateWithTagsArgsForCall)]
	fake.fetchStateWithTagsArgsForCall = append(fake.fetchStateWithTagsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("FetchStateWithTags", []interface{}{arg1Copy})
	fake.fetchStateWithTagsMutex.Unlock()
	if fake.FetchStateWithTagsStub != nil {
		return fake.FetchStateWithTagsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchStateWithTagsReturns.result1, fake.fetchStateWithTagsReturns.result2
}

func (fake *FakeIDal) FetchStateWithTagsCallCount() int {
	fake.fetchStateWithTagsMutex.RLock()
	defer fake.fetchStateWithTagsMutex.RUnlock()
	return len(fake.fetchStateWithTagsArgsForCall)
}

func (fake *FakeIDal) FetchStateWithTagsArgsForCall(i int) []string {
	fake.fetchStateWithTagsMutex.RLock()
	defer fake.fetchStateWithTagsMutex.RUnlock()
	return fake.fetchStateWithTagsArgsForCall[i].arg1
}

func (fake *FakeIDal) FetchStateWithTagsReturns(result1 []byte, result2 error) {
	fake.FetchStateWithTagsStub = nil
	fake.fetchStateWithTagsReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchStateWithTagsReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.FetchStateWithTagsStub = nil
	if fake.fetchStateWithTagsReturnsOnCall == nil {
		fake.fetchStateWithTagsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.fetchStateWithTagsReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) UpdateCheckState(arg1 bool, arg2 string) error {
	fake.updateCheckStateMutex.Lock()
	ret, specificReturn := fake.updateCheckStateReturnsOnCall[len(fake.updateCheckStateArgsForCall)]
	fake.updateCheckStateArgsForCall = append(fake.updateCheckStateArgsForCall, struct {
		arg1 bool
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdateCheckState", []interface{}{arg1, arg2})
	fake.updateCheckStateMutex.Unlock()
	if fake.UpdateCheckStateStub != nil {
		return fake.UpdateCheckStateStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateCheckStateReturns.result1
}

func (fake *FakeIDal) UpdateCheckStateCallCount() int {
	fake.updateCheckStateMutex.RLock()
	defer fake.updateCheckStateMutex.RUnlock()
	return len(fake.updateCheckStateArgsForCall)
}

func (fake *FakeIDal) UpdateCheckStateArgsForCall(i int) (bool, string) {
	fake.updateCheckStateMutex.RLock()
	defer fake.updateCheckStateMutex.RUnlock()
	return fake.updateCheckStateArgsForCall[i].arg1, fake.updateCheckStateArgsForCall[i].arg2
}

func (fake *FakeIDal) UpdateCheckStateReturns(result1 error) {
	fake.UpdateCheckStateStub = nil
	fake.updateCheckStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) UpdateCheckStateReturnsOnCall(i int, result1 error) {
	fake.UpdateCheckStateStub = nil
	if fake.updateCheckStateReturnsOnCall == nil {
		fake.updateCheckStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateCheckStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIDal) GetClusterStats() (*dal.ClusterStats, error) {
	fake.getClusterStatsMutex.Lock()
	ret, specificReturn := fake.getClusterStatsReturnsOnCall[len(fake.getClusterStatsArgsForCall)]
	fake.getClusterStatsArgsForCall = append(fake.getClusterStatsArgsForCall, struct{}{})
	fake.recordInvocation("GetClusterStats", []interface{}{})
	fake.getClusterStatsMutex.Unlock()
	if fake.GetClusterStatsStub != nil {
		return fake.GetClusterStatsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getClusterStatsReturns.result1, fake.getClusterStatsReturns.result2
}

func (fake *FakeIDal) GetClusterStatsCallCount() int {
	fake.getClusterStatsMutex.RLock()
	defer fake.getClusterStatsMutex.RUnlock()
	return len(fake.getClusterStatsArgsForCall)
}

func (fake *FakeIDal) GetClusterStatsReturns(result1 *dal.ClusterStats, result2 error) {
	fake.GetClusterStatsStub = nil
	fake.getClusterStatsReturns = struct {
		result1 *dal.ClusterStats
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterStatsReturnsOnCall(i int, result1 *dal.ClusterStats, result2 error) {
	fake.GetClusterStatsStub = nil
	if fake.getClusterStatsReturnsOnCall == nil {
		fake.getClusterStatsReturnsOnCall = make(map[int]struct {
			result1 *dal.ClusterStats
			result2 error
		})
	}
	fake.getClusterStatsReturnsOnCall[i] = struct {
		result1 *dal.ClusterStats
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchEvents(arg1 []string) ([]byte, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.fetchEventsMutex.Lock()
	ret, specificReturn := fake.fetchEventsReturnsOnCall[len(fake.fetchEventsArgsForCall)]
	fake.fetchEventsArgsForCall = append(fake.fetchEventsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("FetchEvents", []interface{}{arg1Copy})
	fake.fetchEventsMutex.Unlock()
	if fake.FetchEventsStub != nil {
		return fake.FetchEventsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.fetchEventsReturns.result1, fake.fetchEventsReturns.result2
}

func (fake *FakeIDal) FetchEventsCallCount() int {
	fake.fetchEventsMutex.RLock()
	defer fake.fetchEventsMutex.RUnlock()
	return len(fake.fetchEventsArgsForCall)
}

func (fake *FakeIDal) FetchEventsArgsForCall(i int) []string {
	fake.fetchEventsMutex.RLock()
	defer fake.fetchEventsMutex.RUnlock()
	return fake.fetchEventsArgsForCall[i].arg1
}

func (fake *FakeIDal) FetchEventsReturns(result1 []byte, result2 error) {
	fake.FetchEventsStub = nil
	fake.fetchEventsReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) FetchEventsReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.FetchEventsStub = nil
	if fake.fetchEventsReturnsOnCall == nil {
		fake.fetchEventsReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.fetchEventsReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterMembersWithTags() (map[string][]string, error) {
	fake.getClusterMembersWithTagsMutex.Lock()
	ret, specificReturn := fake.getClusterMembersWithTagsReturnsOnCall[len(fake.getClusterMembersWithTagsArgsForCall)]
	fake.getClusterMembersWithTagsArgsForCall = append(fake.getClusterMembersWithTagsArgsForCall, struct{}{})
	fake.recordInvocation("GetClusterMembersWithTags", []interface{}{})
	fake.getClusterMembersWithTagsMutex.Unlock()
	if fake.GetClusterMembersWithTagsStub != nil {
		return fake.GetClusterMembersWithTagsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getClusterMembersWithTagsReturns.result1, fake.getClusterMembersWithTagsReturns.result2
}

func (fake *FakeIDal) GetClusterMembersWithTagsCallCount() int {
	fake.getClusterMembersWithTagsMutex.RLock()
	defer fake.getClusterMembersWithTagsMutex.RUnlock()
	return len(fake.getClusterMembersWithTagsArgsForCall)
}

func (fake *FakeIDal) GetClusterMembersWithTagsReturns(result1 map[string][]string, result2 error) {
	fake.GetClusterMembersWithTagsStub = nil
	fake.getClusterMembersWithTagsReturns = struct {
		result1 map[string][]string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterMembersWithTagsReturnsOnCall(i int, result1 map[string][]string, result2 error) {
	fake.GetClusterMembersWithTagsStub = nil
	if fake.getClusterMembersWithTagsReturnsOnCall == nil {
		fake.getClusterMembersWithTagsReturnsOnCall = make(map[int]struct {
			result1 map[string][]string
			result2 error
		})
	}
	fake.getClusterMembersWithTagsReturnsOnCall[i] = struct {
		result1 map[string][]string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterMemberTags(arg1 string) ([]string, error) {
	fake.getClusterMemberTagsMutex.Lock()
	ret, specificReturn := fake.getClusterMemberTagsReturnsOnCall[len(fake.getClusterMemberTagsArgsForCall)]
	fake.getClusterMemberTagsArgsForCall = append(fake.getClusterMemberTagsArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetClusterMemberTags", []interface{}{arg1})
	fake.getClusterMemberTagsMutex.Unlock()
	if fake.GetClusterMemberTagsStub != nil {
		return fake.GetClusterMemberTagsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getClusterMemberTagsReturns.result1, fake.getClusterMemberTagsReturns.result2
}

func (fake *FakeIDal) GetClusterMemberTagsCallCount() int {
	fake.getClusterMemberTagsMutex.RLock()
	defer fake.getClusterMemberTagsMutex.RUnlock()
	return len(fake.getClusterMemberTagsArgsForCall)
}

func (fake *FakeIDal) GetClusterMemberTagsArgsForCall(i int) string {
	fake.getClusterMemberTagsMutex.RLock()
	defer fake.getClusterMemberTagsMutex.RUnlock()
	return fake.getClusterMemberTagsArgsForCall[i].arg1
}

func (fake *FakeIDal) GetClusterMemberTagsReturns(result1 []string, result2 error) {
	fake.GetClusterMemberTagsStub = nil
	fake.getClusterMemberTagsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetClusterMemberTagsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.GetClusterMemberTagsStub = nil
	if fake.getClusterMemberTagsReturnsOnCall == nil {
		fake.getClusterMemberTagsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getClusterMemberTagsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetCheckMemberTag(arg1 string) (string, error) {
	fake.getCheckMemberTagMutex.Lock()
	ret, specificReturn := fake.getCheckMemberTagReturnsOnCall[len(fake.getCheckMemberTagArgsForCall)]
	fake.getCheckMemberTagArgsForCall = append(fake.getCheckMemberTagArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetCheckMemberTag", []interface{}{arg1})
	fake.getCheckMemberTagMutex.Unlock()
	if fake.GetCheckMemberTagStub != nil {
		return fake.GetCheckMemberTagStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCheckMemberTagReturns.result1, fake.getCheckMemberTagReturns.result2
}

func (fake *FakeIDal) GetCheckMemberTagCallCount() int {
	fake.getCheckMemberTagMutex.RLock()
	defer fake.getCheckMemberTagMutex.RUnlock()
	return len(fake.getCheckMemberTagArgsForCall)
}

func (fake *FakeIDal) GetCheckMemberTagArgsForCall(i int) string {
	fake.getCheckMemberTagMutex.RLock()
	defer fake.getCheckMemberTagMutex.RUnlock()
	return fake.getCheckMemberTagArgsForCall[i].arg1
}

func (fake *FakeIDal) GetCheckMemberTagReturns(result1 string, result2 error) {
	fake.GetCheckMemberTagStub = nil
	fake.getCheckMemberTagReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) GetCheckMemberTagReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetCheckMemberTagStub = nil
	if fake.getCheckMemberTagReturnsOnCall == nil {
		fake.getCheckMemberTagReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getCheckMemberTagReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeIDal) PushConfigs(arg1 string, arg2 map[string][]byte) (int, int, error) {
	fake.pushConfigsMutex.Lock()
	ret, specificReturn := fake.pushConfigsReturnsOnCall[len(fake.pushConfigsArgsForCall)]
	fake.pushConfigsArgsForCall = append(fake.pushConfigsArgsForCall, struct {
		arg1 string
		arg2 map[string][]byte
	}{arg1, arg2})
	fake.recordInvocation("PushConfigs", []interface{}{arg1, arg2})
	fake.pushConfigsMutex.Unlock()
	if fake.PushConfigsStub != nil {
		return fake.PushConfigsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.pushConfigsReturns.result1, fake.pushConfigsReturns.result2, fake.pushConfigsReturns.result3
}

func (fake *FakeIDal) PushConfigsCallCount() int {
	fake.pushConfigsMutex.RLock()
	defer fake.pushConfigsMutex.RUnlock()
	return len(fake.pushConfigsArgsForCall)
}

func (fake *FakeIDal) PushConfigsArgsForCall(i int) (string, map[string][]byte) {
	fake.pushConfigsMutex.RLock()
	defer fake.pushConfigsMutex.RUnlock()
	return fake.pushConfigsArgsForCall[i].arg1, fake.pushConfigsArgsForCall[i].arg2
}

func (fake *FakeIDal) PushConfigsReturns(result1 int, result2 int, result3 error) {
	fake.PushConfigsStub = nil
	fake.pushConfigsReturns = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIDal) PushConfigsReturnsOnCall(i int, result1 int, result2 int, result3 error) {
	fake.PushConfigsStub = nil
	if fake.pushConfigsReturnsOnCall == nil {
		fake.pushConfigsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 error
		})
	}
	fake.pushConfigsReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIDal) PushFullConfigs(arg1 *dal.FullConfigs) (*dal.CfgUtilPushStats, []string) {
	fake.pushFullConfigsMutex.Lock()
	ret, specificReturn := fake.pushFullConfigsReturnsOnCall[len(fake.pushFullConfigsArgsForCall)]
	fake.pushFullConfigsArgsForCall = append(fake.pushFullConfigsArgsForCall, struct {
		arg1 *dal.FullConfigs
	}{arg1})
	fake.recordInvocation("PushFullConfigs", []interface{}{arg1})
	fake.pushFullConfigsMutex.Unlock()
	if fake.PushFullConfigsStub != nil {
		return fake.PushFullConfigsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.pushFullConfigsReturns.result1, fake.pushFullConfigsReturns.result2
}

func (fake *FakeIDal) PushFullConfigsCallCount() int {
	fake.pushFullConfigsMutex.RLock()
	defer fake.pushFullConfigsMutex.RUnlock()
	return len(fake.pushFullConfigsArgsForCall)
}

func (fake *FakeIDal) PushFullConfigsArgsForCall(i int) *dal.FullConfigs {
	fake.pushFullConfigsMutex.RLock()
	defer fake.pushFullConfigsMutex.RUnlock()
	return fake.pushFullConfigsArgsForCall[i].arg1
}

func (fake *FakeIDal) PushFullConfigsReturns(result1 *dal.CfgUtilPushStats, result2 []string) {
	fake.PushFullConfigsStub = nil
	fake.pushFullConfigsReturns = struct {
		result1 *dal.CfgUtilPushStats
		result2 []string
	}{result1, result2}
}

func (fake *FakeIDal) PushFullConfigsReturnsOnCall(i int, result1 *dal.CfgUtilPushStats, result2 []string) {
	fake.PushFullConfigsStub = nil
	if fake.pushFullConfigsReturnsOnCall == nil {
		fake.pushFullConfigsReturnsOnCall = make(map[int]struct {
			result1 *dal.CfgUtilPushStats
			result2 []string
		})
	}
	fake.pushFullConfigsReturnsOnCall[i] = struct {
		result1 *dal.CfgUtilPushStats
		result2 []string
	}{result1, result2}
}

func (fake *FakeIDal) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.setMutex.RLock()
	defer fake.setMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.refreshMutex.RLock()
	defer fake.refreshMutex.RUnlock()
	fake.keyExistsMutex.RLock()
	defer fake.keyExistsMutex.RUnlock()
	fake.isKeyNotFoundMutex.RLock()
	defer fake.isKeyNotFoundMutex.RUnlock()
	fake.createDirectorStateMutex.RLock()
	defer fake.createDirectorStateMutex.RUnlock()
	fake.updateDirectorStateMutex.RLock()
	defer fake.updateDirectorStateMutex.RUnlock()
	fake.newWatcherMutex.RLock()
	defer fake.newWatcherMutex.RUnlock()
	fake.newWatcherForOverwatchMutex.RLock()
	defer fake.newWatcherForOverwatchMutex.RUnlock()
	fake.getClusterMembersMutex.RLock()
	defer fake.getClusterMembersMutex.RUnlock()
	fake.getCheckKeysMutex.RLock()
	defer fake.getCheckKeysMutex.RUnlock()
	fake.getCheckKeysWithMemberTagMutex.RLock()
	defer fake.getCheckKeysWithMemberTagMutex.RUnlock()
	fake.createCheckReferenceMutex.RLock()
	defer fake.createCheckReferenceMutex.RUnlock()
	fake.clearCheckReferenceMutex.RLock()
	defer fake.clearCheckReferenceMutex.RUnlock()
	fake.clearCheckReferencesMutex.RLock()
	defer fake.clearCheckReferencesMutex.RUnlock()
	fake.fetchAllMemberRefsMutex.RLock()
	defer fake.fetchAllMemberRefsMutex.RUnlock()
	fake.fetchCheckStatsMutex.RLock()
	defer fake.fetchCheckStatsMutex.RUnlock()
	fake.fetchAlerterConfigMutex.RLock()
	defer fake.fetchAlerterConfigMutex.RUnlock()
	fake.fetchStateMutex.RLock()
	defer fake.fetchStateMutex.RUnlock()
	fake.fetchStateWithTagsMutex.RLock()
	defer fake.fetchStateWithTagsMutex.RUnlock()
	fake.updateCheckStateMutex.RLock()
	defer fake.updateCheckStateMutex.RUnlock()
	fake.getClusterStatsMutex.RLock()
	defer fake.getClusterStatsMutex.RUnlock()
	fake.fetchEventsMutex.RLock()
	defer fake.fetchEventsMutex.RUnlock()
	fake.getClusterMembersWithTagsMutex.RLock()
	defer fake.getClusterMembersWithTagsMutex.RUnlock()
	fake.getClusterMemberTagsMutex.RLock()
	defer fake.getClusterMemberTagsMutex.RUnlock()
	fake.getCheckMemberTagMutex.RLock()
	defer fake.getCheckMemberTagMutex.RUnlock()
	fake.pushConfigsMutex.RLock()
	defer fake.pushConfigsMutex.RUnlock()
	fake.pushFullConfigsMutex.RLock()
	defer fake.pushFullConfigsMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeIDal) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dal.IDal = new(FakeIDal)
